<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Drawing network graphs with SVG</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://kit.fontawesome.com/abc0295800.js" crossorigin="anonymous"></script>
<style>

    body, html {
        font-family: sans-serif;
        color: #000a12;
        margin: 0;
        padding: 0;
    }

    .hide {
        display: none;
    }

    .show {
        display: inline-block;
    }

    .gray-bg {
        background-color: #eceff1;
    }

    .rounded {
        border-radius: 5px;
    }

    .rounded-full {
        border-radius: 50%;
    }

    .shadow-on-secondary {
        box-shadow: 3px 3px #00897b;
    }

    .shadow-on-gray {
        box-shadow: 2px 2px #AFB1B3;
    }

    .padding-small  {
        padding: 0.5em;
    }

    .neg-margin-small {
        margin-left: -1.5em;
    }

    .icon-med {
        width: 1.5rem;
        height: 1.5rem;
    }

    .wrapper {
        /*display: flex;*/
    }

    #canvas-container{
        width: 95vw;
        height: 95vh;
        margin: 0;
    }

    #controls-container{
        position: fixed;
        top: 0;
        right: 0;
        min-height: 100%;
        width: 2em;
        transition: width 1s;
        overflow: hidden;
        background-color: #4ebaaa;
        box-sizing: border-box;
        border-left: 10px solid #00897b;
        padding: 1em;
        padding-left: 2em;
        margin: 0;
    }

    #controls-container > .controls-body {
        width: 300px;
        display: none;
        margin-left: 2em;
    }

    #controls-container:hover {
        width: 430px;
        transition: width 2s;
        transition-delay: 0.1s;
    }

    #controls-container:hover > .controls-body {
        display: block;
    }

    #controls-container:hover > .icon-med {
        transform: rotate(180deg);
        transition: transform 1s;
    }

    h1 {

        font-size: 1em;
    }

    li {
        list-style-type: none;
    }

    .secondary {
        background-color: #f06292;
    }

    .tertiary {
        background-color: #9575cd;
    }

    .key-marker {
        display: inline-block;
        width: 0.8em;
        height: 0.8em;
    }

    .button {
        background-color: #cfd8dc;
        color: black;
        padding: 0.4em;
        font-size: 0.8em;
        border: 0;
        border-radius: 5px;
    }

</style>

</head>

<body>
    <div class="wrapper">
        <div id="canvas-container">
        </div>
        <div id="controls-container">
            <svg class="neg-margin-small icon-med" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor">
                <path d="M15 19l-7-7 7-7"></path>
                <!-- chevron icon from heroicons -- take a look at https://heroicons.dev/ -->
            </svg>
            
            <h1 class="controls-body">Influence among 500 random philosophers</h1>
            <p class="controls-body">Hover over a node to find out their name, and their relations of influence.</p>
            <section class="gray-bg padding-small controls-body rounded shadow-on-secondary">
                <h1>Key:</h1>
                <ul>
                    <li><div class="key-marker secondary rounded-full"></div> = the person being examined was influenced by the people they have orange links to</li>
                    <li><div class="key-marker tertiary rounded-full"></div> = the person being examined had an influence on the people they have purple links to.</li>
                </ul> 
            </section>
            <br>
            <section class="controls-body gray-bg padding-small rounded shadow-on-secondary">
                <p class="controls-body">The nodes are arranged randomly by default, but they can be re-arranged using the Fruchterman-Reingold algorithm ( still glitches sometimes :[ ).
                </p>
                <button class="button shadow-on-gray" type="button" id="f-r-button">Fruchterman-Reingold</button>
            </section>
        </div>
    </div>
</body>
<script src="drawing-functions.js"></script>
<script src="network-functions.js"></script>
<script src="500-philosophers-response.js"></script>
<script>
    var vWidth = window.innerWidth;
    var vHeight = window.innerHeight;
    var net = {};

    var ns = 'http://www.w3.org/2000/svg';
    var div = document.getElementById('canvas-container'); 
    var svg = document.createElementNS(ns, 'svg');
    svg.setAttributeNS(null, 'width', '100%');
    svg.setAttributeNS(null, 'height', '100%');
    svg.setAttributeNS(null, 'id', 'graph-svg');
    div.appendChild(svg);
    var fRButton = document.getElementById('f-r-button');
    fRButton.addEventListener('click', fR);

    const endpointUrl = 'https://query.wikidata.org/sparql';
    const sparqlQuery1 = `SELECT ?item ?itemLabel (GROUP_CONCAT(?influenced_by;separator=",") as ?inf) WHERE {
      ?item wdt:P106 wd:Q4964182.
      SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
      OPTIONAL { ?item wdt:P737 ?influenced_by. }
    }
    GROUP BY ?item ?itemLabel
    LIMIT 500
    `;

class SPARQLQueryDispatcher {
    constructor( endpoint ) {
        this.endpoint = endpoint;
    }

    query( sparqlQuery ) {
        const fullUrl = this.endpoint + '?query=' + encodeURIComponent( sparqlQuery );
        const headers = { 'Accept': 'application/sparql-results+json' };

        return fetch( fullUrl, { headers } ).then( body => body.json() );
    }
}



function idFromURI(ur){
    return ur.replace("http://www.wikidata.org/entity/", "");
}

function queryAndGraph(graphId){
        const bin = response500; //this won't be the actual return from wd though -- will need to access its 'bindings', first, which is what response500 is taken from.
    
    // //uncomment this block (and '});' at the bottom of this function) to enable live query (and comment the 'const bin =' line above)
    // queryDispatcher.query( sparqlQuery1 ).then( 
    // function(response) {
    //     let bin = response.results.bindings;
    // //end block

        let graphCanvas = document.getElementById(graphId);
        let frame = graphCanvas.getBoundingClientRect();
        let cWidth = frame.width;
        let cHeight = frame.height;
        let idList = {};
        let nodeList = [];
        let edgeList = [];
        for(entry of bin){
            let id = idFromURI(entry.item.value);
            let label = idFromURI(entry.itemLabel.value);
            let influencedBy = entry.inf.value.split(',').map(idFromURI);
            idList[id] = {'label' : label, 'influencedBy' : influencedBy};
        }
            console.log(idList);
        for (entry of Object.keys(idList)){
            nodeList.push(new graphNode(entry, idList[entry].label));
            for (link of findLinks(entry, idList)){
                edgeList.push(link);
            }
        }
        // the following block is to filter and sample the network, to extract a smaller number of connected nodes
        let outNodes = edgeList.map((e) => e.source);
        let inNodes = edgeList.map((e) => e.target);
        let connectedNodeIds = outNodes.concat(inNodes);
        let connectedNodes = [];
        for(node of nodeList){
            if(connectedNodeIds.includes(node.id)){
                connectedNodes.push(node);
            }
        }
        nodeList = connectedNodes;
        // end filtering block 
        
        net = {'nodes' : nodeList, 'edges' : edgeList};

        // console.log(shortestPathBF(net, [{'n' : 0, 'id': 'Q57193'}], 'Q72106', []));
        // console.log('connected component')

        arrangeRandomly(nodeList, cWidth, cHeight);
        sinkSoloNodes(net, cWidth, cHeight, true, 'graph-svg')

        drawGraph(edgeList, nodeList, 'graph-svg');   
    // });
}

function fR(){
    console.log("fr");
    let graphCanvas = document.getElementById('graph-svg');
    let frame = graphCanvas.getBoundingClientRect();
    let cWidth = frame.width;
    let cHeight = frame.height;
    fruchtermanReingold(net, cWidth, cHeight); 
}




//I've stored the results of this query as 'response700' in the '500-philosophers-response.js' doc. You can just plug this response in above and it'll work, although you need to delete the '.value' selectors from three lines in the 'queryAndGraph' function. I'm not sure if that's because the data's structured differently if it's queried using the wikidata website vs a fetch request from here. But just something to remember.
const query2 = `SELECT ?item ?itemLabel (COUNT(?influenced_by) as ?count) (GROUP_CONCAT(?influenced_by;separator=",") as ?inf) WHERE {
              ?item wdt:P106 wd:Q4964182.
              SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
              OPTIONAL { ?item wdt:P737 ?influenced_by. }
            }
            GROUP BY ?item ?itemLabel
            ORDER BY DESC(?count) 
            LIMIT 700`;
            //this query gets you the top 700 most influencED philosophers (bit of a weird one; seems mainly to be famous folks at the top, which I guess reflects how much time people have put into their entries, rather than the fact that they are particularly susceptible to influence).


const queryDispatcher = new SPARQLQueryDispatcher( endpointUrl );



queryAndGraph('graph-svg');

</script>


</html>