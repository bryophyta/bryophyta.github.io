

<div id="canvas-container">

</div>

<script>
var ns = 'http://www.w3.org/2000/svg';

function drawLine(
				canvasId, 
				start, 
				end, 
				weight='2', 
				color="darkgray"
			){
				let canv = document.getElementById(canvasId);
				let line = document.createElementNS(ns, 'line');
				line.setAttributeNS(null, 'x1', start.x);
				line.setAttributeNS(null, 'y1', start.y);
				line.setAttributeNS(null, 'x2', end.x);
				line.setAttributeNS(null, 'y1', end.y);
				line.setAttributeNS(null, 'stroke', color);
				line.setAttributeNS(null, 'stroke-width', weight);
				canv.appendChild(line);
			}

function drawCircle(
					canvasId, 
					x, 
					y, 
					radius='5', 
					fillColor="lightgray", 
					strokeColor="darkgray", 
					strokeWidth="2"
				) {
					let canv = document.getElementById(canvasId);
					let circle = document.createElementNS(ns, 'circle');
					circle.setAttributeNS(null, 'cx', x);
					circle.setAttributeNS(null, 'cy', y);
					circle.setAttributeNS(null, 'r', radius);
					circle.setAttributeNS(null, 'stroke', strokeColor);
					circle.setAttributeNS(null, 'fill', fillColor);
					circle.setAttributeNS(null, 'stroke-width', strokeWidth);
					canv.appendChild(circle);
				}


function pushEdgesFromArray(edgesList, nodesList, sigmaInstance) {
    
    //clear the existing graph
    sigmaInstance.graph.clear()
    //add nodes from the given array to the Sigma graph (in the format it requires), arranging them in a circle as it goes
    nodesList.forEach((e, i, a) =>
        sigmaInstance.graph.addNode({
            id: 'n' + e,
            label: 'Node ' + e,
            x: 6 * Math.cos(((2 * Math.PI) / a.length) * i),
            y: 6 * Math.sin(((2 * Math.PI) / a.length) * i),
            size: 5,
            color: '#666'
        }));


    //add edges from the given array to the Sigma graph
    edgesList.forEach(
        (e, i) =>
        sigmaInstance.graph.addEdge({
            id: 'e' + i,
            source: 'n' + e.source,
            target: 'n' + e.target,
            type: 'arrow',
            size: 3,
            color: '#ccc'
        })
    );
    sigmaInstance.refresh();
}


// a pair of functions to find out the degree of connection of any given node, by looking up the information on the table. This works I think? But it's definitely a solution that makes me think I'm striking a really bad balance between a functional approach and an OO approach? Like, should I just have classes for graph, node, and edge, and then have a canonical representation of the graph which I could call methods on to find information like this?
function containsNode(edge){
    return edge.source == this || edge.target == this;
}

function getNodeDegree(node, edgeArray){
    return edgeArray.filter(containsNode, node).length;
}



function generateRandomNetwork(n, p){
    var nodeList = [];
    var edgeList = [];
    for (let i = 0; i < n; i++){
        nodeList.push(i);
        for (let j = i + 1; j < n; j++){
            if(Math.random() <= p){
                edgeList.push({'source': i, 'target': j});
                edgeList.push({'source': j, 'target': i});
            }
        }
    }
    return {'nodes': nodeList, 'edges': edgeList};
}

function calculateAverageDegree(n){
    var runningTotal = 0;
    let nodeCount = n.nodes.length;
    for(let i = 0; i < nodeCount; i++){
        runningTotal += getNodeDegree(i, n.edges);
    }
    return runningTotal / nodeCount / 2;
}


var div = document.getElementById('canvas-container'); 
var svg = document.createElementNS(ns, 'svg');
svg.setAttributeNS(null, 'width', '100%');
svg.setAttributeNS(null, 'height', '100%');
svg.setAttributeNS(null, 'id', 'graph-svg');
div.appendChild(svg);
// var rect = document.createElementNS(ns, 'rect');
// rect.setAttributeNS(null, 'width', 100);
// rect.setAttributeNS(null, 'height', 100);
// rect.setAttributeNS(null, 'fill', '#f06');
// svg.appendChild(rect);

drawLine('graph-svg', {'x': 1, 'y': 1}, {'x': 20, 'y': 20});
drawCircle('graph-svg', '30', '30');

</script>