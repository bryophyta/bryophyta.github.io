<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Drawing network graphs with SVG</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://kit.fontawesome.com/abc0295800.js" crossorigin="anonymous"></script>
<style>

    body, html {
        font-family: sans-serif;
        color: #000a12;
        margin: 0;
        padding: 0;
    }

    .hide {
        display: none;
    }

    .show {
        display: inline-block;
    }

    .gray-bg {
        background-color: #eceff1;
    }

    .padding-small  {
        padding: 0.5em;
    }

    .neg-margin-small {
        margin-left: -1.5em;
    }

    .wrapper {
        /*display: flex;*/
    }

    #canvas-container{
        width: 95vw;
        height: 95vh;
        margin: 0;
    }

    #controls-container{
        position: fixed;
        top: 0;
        right: 0;
        min-height: 100%;
        width: 2em;
        transition: width 1s;
        overflow: hidden;
        background-color: #ffab91;
        box-sizing: border-box;
        border-left: 10px solid #ff7043;
        padding: 1em;
        padding-left: 2em;
        margin: 0;
    }

    #controls-container > .controls-body {
        width: 300px;
        display: none;
        margin-left: 2em;
    }

    #controls-container:hover {
        width: 430px;
        transition: width 2s;
        transition-delay: 0.1s;
    }

    #controls-container:hover > .controls-body {
        display: block;
    }

    #controls-container:hover > .fa-chevron-left {
        transform: rotate(180deg);
        transition: transform 1s;
    }

    h1 {

        font-size: 1em;
    }

    li {
        list-style-type: square;
    }

    li.secondary::marker { 
        color: #ff7043;
    }

    li.tertiary::marker { 
        color: #9575cd;
    }


</style>

</head>

<body>
    <div class="wrapper">
        <div id="canvas-container">
        </div>
        <div id="controls-container">
            <i class="fas fa-chevron-left neg-margin-small"></i>
            <h1 class="controls-body">Influence among 500 random philosophers</h1>
            <p class="controls-body">Hover over a node to find out their name, and their relations of influence.</p>
            <section class="gray-bg padding-small controls-body">
                <h1>Key:</h1>
                <ul>
                    <li class="secondary">= the person being examined was influenced by the people they have orange links to</li>
                    <li class="tertiary">= the person being examined had an influence on the people they have purple links to.</li>
                </ul> 
            </section>
        </div>
    </div>
</body>
<script src="drawing-functions.js"></script>
<script src="network-functions.js"></script>
<script src="500-philosophers-response.js"></script>
<script>
    var vWidth = window.innerWidth;
    var vHeight = window.innerHeight;
    var net = {};

    var ns = 'http://www.w3.org/2000/svg';
    var div = document.getElementById('canvas-container'); 
    var svg = document.createElementNS(ns, 'svg');
    svg.setAttributeNS(null, 'width', '100%');
    svg.setAttributeNS(null, 'height', '100%');
    svg.setAttributeNS(null, 'id', 'graph-svg');
    // svg.setAttributeNS(null, 'class', 'gray-bg');
    div.appendChild(svg);
    // var searchButton = document.getElementById('searchButton');
    // searchButton.addEventListener('click', searchAndGraph);


    // let net = generateRandomNetwork(15, 0.1);
    // arrangeInCircle(net.nodes, 300, 300, 250);
    // drawGraph(net.edges, net.nodes, 'graph-svg');


function queryAndGraph(graphId){
    //I guess all of the inner content of this function (queryAndGraph()) would be wrapped in an asynch query function?
    let graphCanvas = document.getElementById(graphId);
    let frame = graphCanvas.getBoundingClientRect();
    let cWidth = frame.width;
    let cHeight = frame.height;

    //the following block gets network data from wikidata API response (although see caveat on first line)
        // const bin = response500; //this won't be the actual return from wd though -- will need to access its 'bindings', first, which is what response500 is taken from.
        // let idList = {};
        // let nodeList = [];
        // let edgeList = [];
        // for(entry of bin){
        //     let id = idFromURI(entry.item.value);
        //     if (platoComponentIdList.includes(id)){
        //         let label = idFromURI(entry.itemLabel.value);
        //         let influencedBy = entry.inf.value.split(',').map(idFromURI);
        //         idList[id] = {'label' : label, 'influencedBy' : influencedBy};
        //     }
        // }
        //     console.log(idList);
        // for (entry of Object.keys(idList)){
        //     nodeList.push(new graphNode(entry, idList[entry].label));
        //     for (link of findLinks(entry, idList)){
        //         edgeList.push(link);
        //     }
        // }
    //end network-from-API block

    // //temp block to sub in cube data
        // nodeList = threeBodiesNetwork.nodes;
        // edgeList = threeBodiesNetwork.edges;
    // //end temp block

    //temp block to sub in two random networks connected by a single edge
    let net1 = generateRandomNetwork(100, 0.07, 'a');
    let net2 = generateRandomNetwork(100, 0.07, 'b');
    nodeList = net1.nodes.concat(net2.nodes);
    edgeList = net1.edges.concat(net2.edges);
    for(node of nodeList){
        for (otherNode of nodeList){
            if (node != otherNode){
                if(Math.random() <= 0.0005){
                    edgeList.push({'source': node.id, 'target': otherNode.id});
                }
            }
        }
    }
    edgeList.push({'source' : 'a1', 'target' : 'b1'});
    edgeList.push({'source' : 'a2', 'target' : 'b2'});
    edgeList.push({'source' : 'a3', 'target' : 'b3'});
    net = {'nodes' : nodeList, 'edges' : edgeList};



    fruchtermanReingold(net, cWidth, cHeight);
}



queryAndGraph('graph-svg');

class SPARQLQueryDispatcher {
    constructor( endpoint ) {
        this.endpoint = endpoint;
    }

    query( sparqlQuery ) {
        const fullUrl = this.endpoint + '?query=' + encodeURIComponent( sparqlQuery );
        const headers = { 'Accept': 'application/sparql-results+json' };

        return fetch( fullUrl, { headers } ).then( body => body.json() );
    }
}

const endpointUrl = 'https://query.wikidata.org/sparql';
const sparqlQuery1 = `SELECT ?item ?itemLabel (GROUP_CONCAT(?influenced_by;separator=",") as ?inf) WHERE {
  ?item wdt:P106 wd:Q4964182.
  SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
  OPTIONAL { ?item wdt:P737 ?influenced_by. }
}
GROUP BY ?item ?itemLabel
LIMIT 500
`;

//I've stored the results of this query as 'response700' in the '500-philosophers-response.js' doc. You can just plug this response in above and it'll work, although you need to delete the '.value' selectors from three lines in the 'queryAndGraph' function. I'm not sure if that's because the data's structured differently if it's queried using the wikidata website vs a fetch request from here. But just something to remember.
const query2 = `SELECT ?item ?itemLabel (COUNT(?influenced_by) as ?count) (GROUP_CONCAT(?influenced_by;separator=",") as ?inf) WHERE {
              ?item wdt:P106 wd:Q4964182.
              SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
              OPTIONAL { ?item wdt:P737 ?influenced_by. }
            }
            GROUP BY ?item ?itemLabel
            ORDER BY DESC(?count) 
            LIMIT 700`;
            //this query gets you the top 700 most influencED philosophers (bit of a weird one; seems mainly to be famous folks at the top, which I guess reflects how much time people have put into their entries, rather than the fact that they are particularly susceptible to influence).


const queryDispatcher = new SPARQLQueryDispatcher( endpointUrl );


function idFromURI(ur){
    return ur.replace("http://www.wikidata.org/entity/", "");
}

function searchAndGraph(){

    // sparqlId = document.getElementById('searchId').value;

    queryDispatcher.query( sparqlQuery1 ).then( 
        function(response) {
            let bin = response.results.bindings;
            console.log(bin);
            let idList = {};
            let nodeList = [];
            let edgeList = [];
            for (entry of bin){
                let id = idFromURI(entry.item.value);
                let label = idFromURI(entry.itemLabel.value);
                let influencedBy = idFromURI(entry.influenced_by.value);
                if (! Object.keys(idList).includes(id)) {
                    idList[id] = {'label' : label, 'influencedBy' : [influencedBy]};
                } else {
                    idList[id]['influencedBy'].push(influencedBy);
                }
            }
            for (entry of Object.keys(idList)){
                nodeList.push(new graphNode(entry, idList[entry].label));
                for (link of findLinks(entry, idList)){
                    edgeList.push(link);
                }
            }
            arrangeInCircle(
                                nodeList,
                                (vWidth/4),
                                (vHeight/2),
                                vWidth/2 < vHeight ? (vWidth/4-20) : (vHeight/2-20)
                            );
            console.log(nodeList);
            drawGraph(edgeList, nodeList, 'graph-svg');
            net = {'nodes' : nodeList, 'edges' : edgeList};
        }
    );
}


</script>


</html>