<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Graphing networks of influence among philosophers, according to WikiData">
    <title>Philosophy influence network graph</title>
<style>

    body, html {
        font-family: sans-serif;
        color: #000a12;
        margin: 0;
        padding: 0;
    }

    .hide {
        display: none;
    }

    .show {
        display: inline-block;
    }

    .gray-bg {
        background-color: #eceff1;
    }

    .rounded {
        border-radius: 5px;
    }

    .rounded-full {
        border-radius: 50%;
    }

    .shadow-on-secondary {
        box-shadow: 3px 3px #00897b;
    }

    .shadow-on-gray {
        box-shadow: 2px 2px #AFB1B3;
    }

    .padding-small  {
        padding: 0.5em;
    }

    .neg-margin-small {
        margin-left: -1.5em;
    }

    .icon-med {
        width: 1.5rem;
        height: 1.5rem;
    }

    .wrapper {
        /*display: flex;*/
    }

    .body-wrapper {
        width: 95vw;
        height: 100vh;
        display: flex;
    }

    .info-box {
        /*background-color: #99ff99;*/
        flex-grow: 1;
    }

    #canvas-container{
        width: 80vw;
        height: 95vh;
        margin: 0;
    }

    #controls-container{
        position: fixed;
        top: 0;
        right: 0;
        min-height: 100%;
        width: 2em;
        transition: width 1s;
        overflow: hidden;
        background-color: #4ebaaa;
        box-sizing: border-box;
        border-left: 10px solid #00897b;
        padding: 1em;
        padding-left: 2em;
        margin: 0;
    }

    #controls-container > .controls-body {
        width: 300px;
        display: none;
        margin-left: 2em;
    }

    #controls-container:hover {
        width: 430px;
        transition: width 2s;
        transition-delay: 0.1s;
    }

    #controls-container:hover > .controls-body {
        display: block;
    }

    #controls-container:hover > .icon-med {
        transform: rotate(180deg);
        transition: transform 1s;
    }

    h1 {

        font-size: 1em;
    }

    li {
        list-style-type: none;
    }

    .blue {
        background-color: #039be5;
    }

    .purple {
        background-color: #9575cd;
    }

    .secondary {
        background-color: #f06292;
    }

    .tertiary {
        background-color: #9575cd;
    }

    .key-marker {
        display: inline-block;
        width: 0.8em;
        height: 0.8em;
        margin-left: 0.2em;
        margin-right: 0.2em;
    }

    .button {
        background-color: #cfd8dc;
        color: black;
        padding: 0.4em;
        font-size: 0.8em;
        border: 0;
        border-radius: 5px;
    }

</style>

</head>

<body>
    <div class="wrapper">
        <div class="body-wrapper">
            <section class="info-box gray-bg padding-small">
                <h1>Graph information</h1>
                <h2>Total nodes</h2>
                <p><span id="nodeCount"></span> nodes</p>
                <h2>Highest degree</h2>
                <p><div class="key-marker blue rounded-full"></div>
                <span id="highestDegreeName"></span> (<span id="highestDegreeCount"></span> links)</p>
                <h2>Longest path (diameter)</h2>
                <p><span id="diameterCount"></span> links</p>
                <p>
                    e.g.: <div class="key-marker secondary rounded-full"></div> 
                    <span id="aNode"></span> 
                    <br>to<br> 
                    <div class="key-marker purple rounded-full"></div>
                    <span id="bNode"></span>
                </p>
            </section>
            <div id="canvas-container">
                <svg id="philCanvas" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
            </div>
        </div>
        <div id="controls-container">
            <svg class="neg-margin-small icon-med" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor">
                <path d="M15 19l-7-7 7-7"></path>
                <!-- chevron icon from heroicons -- take a look at https://heroicons.dev/ -->
            </svg>
            
            <h1 class="controls-body">Influence graph</h1>
            <p class="controls-body">This graph displays connections of influence among philosophers, according to WikiData.</p>
            <p class="controls-body">The query retrieves data about all philosophers on WikiData who have data about their influences.</p>
            <p class="controls-body">I then use a breadth-first search to find the largest connected component in the total network of influence, which is then graphed on this page.</p>
            <p class="controls-body">It then analyses the resulting network for certain key properties, displayed on the right hand side of the page.</p>
            <p class="controls-body">The same code can be re-deployed with a different initial query, for example using data on enemies among comic book characters.</p>
        </div>
    </div>
</body>
<!-- <script src="drawing-functions.js"></script> -->
<script src="network-functions.js"></script>
<script src="network-descriptions.js"></script>
<script src="enemiesData.js"></script>

<script>
    function idFromURI(ur){
        return ur.replace("http://www.wikidata.org/entity/", "");
    }
    
    // Runs BFS but returns the list of nodes covered in the process, which will map the largest connected component which includes the initially provided node.
    function connectedComponentMapBF(
                edges,
                queue,
                covered,
                upperBound = null
        ) {
        if (queue.length > 0){
            const current = queue.shift();
            const currNode = current.node;
            const depth = current.depth;


            // by default this function will map the whole connected component, but if an upper bound is passed then it will only map up to that depth from the initial node.
            if (upperBound && depth >= upperBound) {
                return covered;
            }

            const nextOutNodes = edges
                .filter((e) => e.source === currNode)
                .map((e) => e.target);
            const nextInNodes = edges
                .filter((e) => e.target === currNode)
                .map((e) => e.source);
            const nextLevelNodes = nextOutNodes.concat(nextInNodes);

            for (let nodeId of nextLevelNodes) {
                if (!covered.includes(nodeId)) {
                    queue.push({ node: nodeId, depth: depth + 1 });
                    covered.push(nodeId);
                }
            }

            return connectedComponentMapBF(edges, queue, covered, upperBound);
        
        } else {
            // return a list of all the ids discovered in the search process (all those nodes in the largest connected component which includes the start node) 
            return covered;
        }
    }

    function findLargestComponent(nodes, edges){
        const runningCoveredList = [];
        const components = [];
        for (let node of nodes) {
            if (! runningCoveredList.includes(node)){
                const connectedComponent = connectedComponentMapBF(edges, [{node: node, depth: 0}], [node]);
                runningCoveredList.push(...connectedComponent);
                components.push(connectedComponent);
            }
        }
        let largestComponent = [];
        for (let component of components) {
            if (component.length > largestComponent.length) {
                largestComponent = component;
            }
        }
        return largestComponent;
    }



    const canvas = document.querySelector('#philCanvas');
    const philGraph = new Graph({
                            canvas: canvas,
                            primaryDark: '#212121',
                            primaryMid: '#424242'
        });

   

    const nodes = [];
    const nodeIds = [];
    const edges = [];
   
    for (let entry of enemiesData.results.bindings){
        const id = idFromURI(entry.item.value);
        if (! nodeIds.includes(id)) {
            const label = entry.itemLabel.value;
            const infId = idFromURI(entry.enemy.value);
            const infLabel = entry.enemyLabel.value;
            nodes.push({
                id: id,
                label: label,
                // displayLabel: true
            });
            nodeIds.push(id);

            if (! nodeIds.includes(infId)) {
                nodes.push({
                    id: infId,
                    label: infLabel,
                    // displayLabel: true
                });
                nodeIds.push(infId);
            }
            edges.push({source: id, target: infId});
        }

    }


    const largestComponent = findLargestComponent(nodeIds, edges);
    //= connectedComponentMapBF(edges, [{node: 'Q868', depth: 0}], [], 10);
    const componentNodes = nodes.filter((n) => largestComponent.includes(n.id));
    const componentEdges = edges.filter((e) => largestComponent.includes(e.target) && largestComponent.includes(e.source));
    // philGraph.generateRandomNetwork(200, 0.1);
    for (let node of componentNodes) {
        philGraph.addNode(node);
    }
    for (let edge of componentEdges) {
        philGraph.addEdge(edge);
    }
    philGraph.fruchtermanReingold(10, 1);
    philGraph.draw();

    const avDegree = componentNodes.length / componentEdges.length;


    let highestDegree = 0;
    let highestNode;
    for (let id of philGraph.nodeIds) {
        const degree = philGraph.degree(id);
        if (degree > highestDegree) {
            highestDegree = degree;
            highestNode = philGraph.nodeDictionary[id];
        }
    }
    highestNode.weight = 3;
    highestNode.fillColor = '#039be5';
    highestNode.strokeColor = '#424242';

    let longestPath = 0;
    let ends = [];
    const n = philGraph.nodeIds.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
                const pathLength = philGraph.shortestPath(philGraph.nodeIds[i], philGraph.nodeIds[j]);
                if (pathLength === longestPath) {
                    ends.push({a: `${philGraph.nodeIds[i]}`, b: `${philGraph.nodeIds[j]}`});
                }
                if (pathLength > longestPath) {
                    longestPath = pathLength;
                    ends = [{a: `${philGraph.nodeIds[i]}`, b: `${philGraph.nodeIds[j]}`}];
                }
        }
    }
    const line = ends[Math.floor(Math.random() * (ends.length - 1))]; 
    const aNode = philGraph.nodeDictionary[line.a];
    const bNode = philGraph.nodeDictionary[line.b];
    aNode.weight = 3;
    bNode.weight = 3;
    aNode.fillColor = '#f06292';
    aNode.strokeColor = '#f06292';
    bNode.fillColor = '#9575cd';
    bNode.strokeColor = '#9575cd';

    
    const nCount = document.querySelector('#nodeCount');
    const hDName = document.querySelector('#highestDegreeName');
    const hDCount = document.querySelector('#highestDegreeCount');
    const diamCount = document.querySelector('#diameterCount');
    const aNodeName = document.querySelector('#aNode');
    const bNodeName = document.querySelector('#bNode');
    nCount.innerHTML = philGraph.nodes.length;
    hDName.innerHTML = highestNode.label;
    hDCount.innerHTML = highestDegree;
    diamCount.innerHTML = longestPath;
    aNodeName.innerHTML = aNode.label;
    bNodeName.innerHTML = bNode.label;

    philGraph.refresh();

//     const div = document.getElementById('canvas-container'); 
//     const svg = document.createElementNS(ns, 'svg');
//     svg.setAttributeNS(null, 'width', '100%');
//     svg.setAttributeNS(null, 'height', '100%');
//     svg.setAttributeNS(null, 'id', 'graph-svg');
//     div.appendChild(svg);
//     const fRButton = document.getElementById('f-r-button');
//     fRButton.addEventListener('click', fR);

//     const endpointUrl = 'https://query.wikidata.org/sparql';
//     const sparqlQuery1 = `SELECT ?item ?itemLabel (GROUP_CONCAT(?influenced_by;separator=",") as ?inf) WHERE {
//       ?item wdt:P106 wd:Q4964182.
//       SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
//       OPTIONAL { ?item wdt:P737 ?influenced_by. }
//     }
//     GROUP BY ?item ?itemLabel
//     LIMIT 500
//     `;

//     const sparqlQueryAllPhil = `SELECT ?item ?itemLabel ?influenced_by ?influenced_byLabel
//                         WHERE 
//                         {
//                           ?item wdt:P106 wd:Q4964182;
//                                 wdt:P737 ?influenced_by. #This means only those people who have an influenced_by will be returned
//                           SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
//                         }`;

// class SPARQLQueryDispatcher {
//     constructor( endpoint ) {
//         this.endpoint = endpoint;
//     }

//     query( sparqlQuery ) {
//         const fullUrl = this.endpoint + '?query=' + encodeURIComponent( sparqlQueryAllPhil );
//         const headers = { 'Accept': 'application/sparql-results+json' };

//         return fetch( fullUrl, { headers } ).then( body => body.json() );
//     }
// }




// function queryAndGraph(graphId){
//         const bin = allPhilosophers.results.bindings; //this won't be the actual return from wd though -- will need to access its 'bindings', first, which is what response500 is taken from.
    
//     //uncomment this block (and '});' at the bottom of this function) to enable live query (and comment the 'const bin =' line above)
//     // queryDispatcher.query( sparqlQueryAllPhil ).then( 
//     // function(response) {
//     //     let bin = response.results.bindings;
//     //end block

//         let graphCanvas = document.getElementById(graphId);
//         let frame = graphCanvas.getBoundingClientRect();
//         let cWidth = frame.width;
//         let cHeight = frame.height;
//         let nodeInfo = {};
//         //feels a bit awkward having this 'idList' running alongside the population of the nodeInfo object, given that they end up duplicating information. But I need to only create edges for influencers who are also nodes, and having this parallel list feels like it will be cheaper than always looking up the nodeInfo keys and searching through those? Not quite sure though.
//         let idList = [];
//         let nodeList = [];
//         let edgeList = [];
//         for(entry of bin){
//             let id = idFromURI(entry.item.value);
//             let label = idFromURI(entry.itemLabel.value);
//             let influencedBy = idFromURI(entry.influenced_by.value);
//             if (idList.includes(id)){
//                 nodeInfo[id].influencedBy.push(influencedBy);
//             } else {
//                 idList.push(id);
//                 nodeInfo[id] = {'label' : label, 'influencedBy' : [influencedBy]};
//             }
//         }

//         for (entry of Object.keys(nodeInfo)){
//             nodeList.push(new graphNode(entry, nodeInfo[entry].label));
//             for (influencer of nodeInfo[entry].influencedBy){
//                 if (idList.includes(influencer)){
//                     edgeList.push({'source' : entry, 'target' : influencer, 'color' : '', 'weight' : ''});
//                 }
//             }
//         }

//         // the following block is to filter and sample the network, to extract a smaller number of connected nodes
//         // let outNodes = edgeList.map((e) => e.source);
//         // let inNodes = edgeList.map((e) => e.target);
//         // let connectedNodeIds = outNodes.concat(inNodes);
//         // let connectedNodes = [];
//         // for(node of nodeList){
//         //     if(connectedNodeIds.includes(node.id)){
//         //         connectedNodes.push(node);
//         //     }
//         // }
//         // nodeList = connectedNodes;
//         // end filtering block 
        

//         net = {'nodes' : nodeList, 'edges' : edgeList};
//         nodeList = trimSoloNodes(net);
//         net = {'nodes' : nodeList, 'edges' : edgeList};

//         // console.log(shortestPathBF(net, [{'n' : 0, 'id': 'Q57193'}], 'Q72106', []));
//         // console.log('connected component')

//         arrangeRandomly(nodeList, cWidth, cHeight);
//         // sinkSoloNodes(net, cWidth, cHeight, true, 'graph-svg')


//         drawGraph(net.edges, net.nodes, 'graph-svg');   
        
//         // console.log(connectedComponentMapBF(net, [{'id' : 'Q868', 'n' : 0}], 'l', []));

//         // fruchtermanReingold(net, cWidth, cHeight); 
//     // });
// }

// function fR(){
//     console.log("fr");
//     let graphCanvas = document.getElementById('graph-svg');
//     let frame = graphCanvas.getBoundingClientRect();
//     let cWidth = frame.width;
//     let cHeight = frame.height;
//     fruchtermanReingold(net, cWidth, cHeight); 
// }




// //I've stored the results of this query as 'response700' in the '500-philosophers-response.js' doc. You can just plug this response in above and it'll work, although you need to delete the '.value' selectors from three lines in the 'queryAndGraph' function. I'm not sure if that's because the data's structured differently if it's queried using the wikidata website vs a fetch request from here. But just something to remember.
// const query2 = `SELECT ?item ?itemLabel (COUNT(?influenced_by) as ?count) (GROUP_CONCAT(?influenced_by;separator=",") as ?inf) WHERE {
//               ?item wdt:P106 wd:Q4964182.
//               SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
//               OPTIONAL { ?item wdt:P737 ?influenced_by. }
//             }
//             GROUP BY ?item ?itemLabel
//             ORDER BY DESC(?count) 
//             LIMIT 700`;
//             //this query gets you the top 700 most influencED philosophers (bit of a weird one; seems mainly to be famous folks at the top, which I guess reflects how much time people have put into their entries, rather than the fact that they are particularly susceptible to influence).


// const queryDispatcher = new SPARQLQueryDispatcher( endpointUrl );



// queryAndGraph('graph-svg');

</script>


</html>