<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>A small site about network visualisation</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <div class="wrapper p-2">
        <h1>Fruchterman-Reingold</h1>
            <div class="row purple">
                <div class="canvas-container bg-grey-100 rounded p-2 mt-4 mt-1">
                    <svg id="canvasQuestion" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
                </div>
                <div class="flex med-mt-4 mt-1">
                    <p class="text-default-color mt-1 med-mt-0">Visualising networks can be tricky.</p>
                </div>
            </div>
            <div class="row">
                <div class="canvas-container bg-grey-100 rounded p-2 mt-4 mt-1">
                    <svg id="canvasCircle" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
                </div>
                <div class="flex med-mt-4 mt-1">
                    <p class="text-default-color mt-1 med-mt-0">Circles are neat for small networks, but quickly become unwieldy.</p>
                </div>
            </div>
            <div class="row">
                <div class="canvas-container bg-grey-100 rounded p-2 mt-4 mt-1">
                    <svg id="canvasRandom" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
                </div>
                <div class="flex med-mt-4 mt-1">
                    <p class="text-default-color mt-1 med-mt-0">Random placement generally makes more efficient use of space, but the relative positions of the nodes tell you nothing about their relationships.</p>
                </div>
            </div>
                <div class="flow-break rounded p-2 mt-4 mt-1 bg-grey-100 center-text">
                <p class="text-default-color">What alternatives are there?</p>
                </div>
            <div class="row pink">
                <div class="canvas-container bg-grey-100 rounded p-2 mt-4 mt-1">
                    <svg id="canvasTriangle" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
                </div>
                <div class="med-mt-4 mt-1 flex">
                    <p class="text-default-color mt-1 med-mt-0">One approach is to use the Fruchterman-Reingold algorithm. This treats the nodes like particles which interact with one another. All nodes repel each other. But nodes connected by edges also attract each other. You can see how it works with this triangular network.</p>
                    <div class="play-controls">
                        <button id="myButton" class="icon-button" aria-labelledby="button-label" data-function="play" data-graph="triangle"> 
                            <span id="button-label" hidden>Play</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                        </button>
<!--                         <div class="icon-button">
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><circle cx="10" cy="10" r="40%"></circle></svg>
                        </div> -->
                        <button class="icon-button" aria-labelledby="button-label" data-function="reset" data-graph="triangle"> 
                            <span id="button-label" hidden>Reset</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path></svg>
                        </button> 
                    </div>
                </div>
            </div>
            <div class="row orange">
                <div class="canvas-container bg-grey-100 rounded p-2 mt-4 mt-1">
                    <svg id="canvas" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
                </div>
                <div class="med-mt-4 mt-1 flex">
                    <p class="text-default-color mt-1 med-mt-0">This produces some interesting effects with networks which mirror the 'wireframe' for familiar shapes, like this graph which usually turns into a cube when you run the algorithm on it. (Occasionally it doesn't, because the final state of this algorithm depends on where the nodes start off.)</p>
                    <div class="play-controls">
                        <button id="myButton" class="icon-button" aria-labelledby="button-label" data-function="play" data-graph="cube"> 
                            <span id="button-label" hidden>Play</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                        </button>
<!--                         <div class="icon-button">
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><circle cx="10" cy="10" r="40%"></circle></svg>
                        </div> -->
                        <button class="icon-button" aria-labelledby="button-label" data-function="reset" data-graph="cube"> 
                            <span id="button-label" hidden>Reset</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path></svg>
                        </button> 
                    </div>
                </div>
            </div>
            <div class="row teal">
                <div class="canvas-container bg-grey-100 rounded p-2 mt-4 mt-1">
                    <svg id="canvasHub1" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
                </div>
                <div class=" med-mt-4 mt-1 flex">
                    <p class="text-default-color mt-1 med-mt-0">But it's also useful for re-arranging more complex network graphs in a way that is easier for people to read. For example, it usually brings out the hub-and-spoke structure of this graph very clearly.</p>
                    <div class="play-controls">
                        <button id="myButton" class="icon-button" aria-labelledby="button-label" data-function="play" data-graph="hub1"> 
                            <span id="button-label" hidden>Play</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                        </button>
<!--                         <div class="icon-button">
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><circle cx="10" cy="10" r="40%"></circle></svg>
                        </div> -->
                        <button class="icon-button" aria-labelledby="button-label" data-function="reset" data-graph="hub1"> 
                            <span id="button-label" hidden>Reset</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path></svg>
                        </button> 
                    </div>
                </div>
            </div>
            <div class="row blue">
                <div class="canvas-container bg-grey-100 rounded p-2 mt-4 mt-1">
                    <svg id="canvasHub2" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"></svg>
                </div>
                <div class="med-mt-4 mt-1 flex">
                    <p class="text-default-color mt-1 med-mt-0">And it also works pretty well on some more complex graphs, too.</p>
                    <div class="play-controls">
                        <button id="myButton" class="icon-button" aria-labelledby="button-label" data-function="play" data-graph="hub2"> 
                            <span id="button-label" hidden>Play</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                        </button>
<!--                         <div class="icon-button">
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><circle cx="10" cy="10" r="40%"></circle></svg>
                        </div> -->
                        <button class="icon-button" aria-labelledby="button-label" data-function="reset" data-graph="hub2"> 
                            <span id="button-label" hidden>Reset</span>
                            <svg width="100%" height="100%" aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path></svg>
                        </button> 
                    </div>
                </div>
            </div>
            <div class="flow-break bg-grey-100 p-2 mt-4 mt-1 mb-4 rounded">
                <p class="text-default-color">To find out more, take a look at Fruchterman and Reingold's original paper.</p>
                <p class="text-default-color">You can find it through a Google Scholar search: <a href="https://scholar.google.co.uk/scholar?hl=en&as_sdt=0%2C5&q=Fruchterman+Reingold.+Graph+drawing+by+force-directed+placement&btnG=" target="_blank">T. Fruchterman and E. Reingold. Graph drawing by force-directed placement. <i>Journal of Software: Practice and Experience</i>, 21(11):1129–1164, 1991</a>.</p>
                <p class="text-default-color">My implementation is based on the pseudo-code provided in that paper. You can also view <a href="network-functions.ts">the code I wrote to draw the graphs and to run the node-placement algorithm</a> (TypeScript).</p>
            </div>
    </div>
</body>
<script src="network-functions.js"></script>
<script src="network-descriptions.js"></script>
<script>
    //initialising the various graphs on the page; pulling data from network-descriptions where relevant
    const canvasQuestion = document.querySelector('#canvasQuestion');
    const canvas = document.querySelector(`#canvas`);
    const canvasRandom = document.querySelector('#canvasRandom');
    const canvasHub1 = document.querySelector('#canvasHub1');
    const canvasTriangle = document.querySelector('#canvasTriangle');
    const canvasCircle = document.querySelector('#canvasCircle');


    const qW = canvasQuestion.clientWidth;
    const qH = canvasQuestion.clientHeight;
    const questionMark = {
                        nodes: [
                                {id: 'a', x: (qW/4).toString(), y: (qH/10*2).toString()},
                               {id: 'a1', x: (qW/2).toString(), y: (qH/10*1).toString()},
                                {id: 'b', x: (qW/4*3).toString(), y: (qH/10*2).toString()},
                                {id: 'c', x: (qW/4*3).toString(), y: (qH/10*4).toString()},
                                {id: 'd', x: (qW/5*2).toString(), y: (qH/10*5).toString()},
                                {id: 'e', x: (qW/2).toString(), y: (qH/10*7).toString()},
                                {id: 'f', x: (qW/2).toString(), y: (qH/10*9).toString()}
                        ],
                        edges: [
                                {source: 'a', target: 'a1'},
                                {source: 'a1', target: 'b'},
                                {source: 'b', target: 'c'},
                                {source: 'c', target: 'd'},
                                {source: 'd', target: 'e'},
                                ]
    }

    const circleGraph = new Graph({canvas: canvasCircle});
    let circleNodes = 10;
    window.setInterval(circleAnimate, 1000);
    function circleAnimate(){
        if (circleNodes > 50) {
            circleNodes = 10;
        }
        circleGraph.nodes = [];
        circleGraph.nodeIds = [];
        circleGraph.nodeDictionary = {};
        circleGraph.edges = [];
        circleGraph.generateRandomNetwork(circleNodes, 0.1);
        circleGraph.arrangeInCircle();
        circleGraph.refresh();
        circleNodes += 5;
    }

    const triangleColor = getComputedStyle(canvasTriangle).color;
    const triangleGraph = new Graph({
                                canvas: canvasTriangle,
                                nodes: triangle.nodes,
                                edges: triangle.edges,
                                primaryDark: triangleColor,
                                primaryMid: triangleColor,
                                weightFactor: 5
                            });
    triangleGraph.draw();

    const questionColor = getComputedStyle(canvasQuestion).color;
    const questionGraph = new Graph(
                                {
                                    canvas: canvasQuestion,
                                    nodes: questionMark.nodes,
                                    edges: questionMark.edges,
                                    primaryDark: questionColor,
                                    primaryMid: '#9575cd',
                                    weightFactor: 10
                                });
    for (let node of questionGraph.nodes) {
        node.weight = 0.5;
    }
    questionGraph.draw();



    const cubeColor = getComputedStyle(canvas).color;
    const cubeGraph = new Graph({
                                canvas: canvas,
                                nodes: cube.nodes,
                                edges: cube.edges,
                                primaryDark: cubeColor,
                                primaryMid: cubeColor,
                                weightFactor: 3
                            });
    cubeGraph.draw();

    const randomGraph = new Graph({canvas: canvasRandom});
    randomGraph.generateRandomNetwork(50, 0.1);
    randomGraph.draw();

    const hubColor = getComputedStyle(canvasHub1).color;
    const hubGraph = new Graph({
                                canvas: canvasHub1,
                                nodes: hubAndSpokes.nodes,
                                edges: hubAndSpokes.edges,
                                primaryDark: hubColor,
                                primaryMid: '#00796b',
                                weightFactor: 2
                            });
    hubGraph.draw();

    const hub2Color = getComputedStyle(canvasHub2).color;
    const hubGraph2 = new Graph({
                                canvas: canvasHub2,
                                nodes: hubAndSpokes2.nodes,
                                edges: hubAndSpokes2.edges,
                                primaryDark: hub2Color,
                                primaryMid: hub2Color
                            });
    hubGraph2.draw();

    //setting up the play/reset controls
    const graphDictionary = {
        'cube': cubeGraph,
        'hub1': hubGraph,
        'hub2': hubGraph2,
        'triangle': triangleGraph,
    }

    function playResetHandle(event) {
        const button = event.currentTarget;
        const graph = graphDictionary[button.dataset.graph];
        if (button.dataset.function === 'play') {
            if (! graph.playing) {
                graph.fruchtermanReingoldAnimate(10, 1);
            }
        }
        if (button.dataset.function === 'reset') {
            graph.playing = false;
            graph.arrangeRandomly();
            graph.refresh();
        }
    }

    const playButtons = document.querySelectorAll('.icon-button');
    playButtons.forEach((b) => b.addEventListener('mousedown', playResetHandle));
    window.addEventListener('keydown', (e) => {
            if ((e.keyCode === 13 || e.keyCode === 32) && e.target.classList.contains('icon-button')){
                playResetHandle({currentTarget: e.target})
            }
        });
</script>


</html>